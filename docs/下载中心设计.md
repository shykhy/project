## 下载中心设计

### 背景

目前商户平台、卡管理平台等系统的数据下载存在如下问题：

1. 每个需要数据导出的地方需要开发人员单独写相关导出代码；
2. 数据量稍大就会崩溃；
3. 下载逻辑直接在业务系统实现，下载的数据量一大会影响业务系统的稳定性；

### 目标

下载中心需要实现如下目标：

1. 通用。可供商户平台、卡管理后台甚至是第三方使用；
2. 异步。能够异步处理下载逻辑，实现后台运行；
3. 对大数据量的下载支持。最高能支持 1G 的数据量下载；
4. 多种下载格式的支持。需要支持 csv 和 excel 格式的下载需求；
5. 模板化。针对 excel 格式的下载，可配置 excel 模板；
6. 安全性，因为每个下载操作都是较重的，如果客户端不断发起下载请求，则会耗尽系统资源；
7. 合理的反馈机制。需要实现三种反馈机制：
   - 异步回调：调用方提交任务时提供 callback，下载中心任务完成时通知对方，一般用于对方是后台程序下载的情况；
   - 轮询-回复：调用方提交任务后建立到下载中心的 WebSocket 连接，下载中心任务完成后回复 WebSocket；
   - 被动查询：提供根据 project_i、task_id 查询任务（列表）；
   - 同步调用：同步阻塞获取数据，一般用于数据量不大的场景；

### 实现

1. 下载中心以项目作为管理、组织形式：项目 - 任务；
2. 业务系统在下载中心注册，下载中心分配一个 project_id；
3. 业务系统向下载中心发起下载请求，请求参数包括：
   - **source_url**：数据源 url。下载中心从该 url 分页获取需要的数据。业务系统指定该 url 时，需要将用户的过滤条件作为参数带上（换句话说，下载中心会严格按照业务系统提供的 url 来获取参数）；
   - **project_id**：后面业务系统可以根据此 proj_id 从下载中心查询到其下的下载任务列表；
   - **file_name**：文件名称，可选，不提供则按日期随机生成；
   - **title**：可选。表格标题，不提供则不显示（仅对 excel 有效）；
   - **summary**：摘要。可选。如果提供了，则生成 excel 摘要区。仅对 excel 有效；
   - **type**：可选。csv 或 excel，默认 csv；
   - **operator_id**：操作员编号。
   - **template**: {…} 表头格式定义，仅对 excel 生效，详见后面说明
   - **callback**: 回调 url，如果提供了，文件生成后通过此 url 通知业务系统
   - **page_size**：指定下载中心下载数据时每次取多少数据，默认 500，可设置范围：100 - 1000
4. 下载中心创建一条下载任务，并返回任务编号给业务系统；
5. 业务系统可以向下载中心发起 Web Socket 连接，用来主动接收下载完成的通知（主动模式）；
6. 业务系统也可以不建立 Web Socket 连接，而是让用户过一会去某个地方查看（被动模式）；
7. 下载中心从 source_url 异步分页获取数据，暂存到临时文件中；
8. 下载中心解析 excel 模板和数据，生成目标文件（如果是 csv 则直接将上面到临时文件拷贝成目标文件）。如果文件很大，可能会分成多个文件并打包压缩；
9. 下载中心更新任务状态，并通知业务系统（如果有 Web Socket 连接到话）；
10. 用户点击下载，下载目标文件到本地；
11. 下载中心定期清理过期的文件；

### 图示

![img](http://showdoc.wcc.cn/Public/Uploads/2020-04-08/5e8da6db0c780.png)

### 业务系统最佳实践：

1. 主动模式：采用 Web Socket 主动接收下载完成的通知；
2. 被动模式：在统一的地方管理下载任务；
3. 异步回调模式：下载中心处理完成后回调通知业务系统；

### 设计

一个 excel 有多个 worksheet 组成，下面的设计是针对一个 worksheet 中的元素。

- 一个 worksheet 由**数据区**和**图表区**组成。第一期不涉及图表区。

- 每个 excel 可以生成多个 sheet，每个 sheet 仅支持一个表格。

- 数据区的组成：

  - 标题区（title）。可选
  - 摘要区（summary）。可选。表格的说明文字、注意事项、名词解释等
  - 头部（header）。可选。
  - 表头（table-header）。必须
  - 数据区（data）。必须
  - 页脚(footer)。可选
    ![img](http://showdoc.wcc.cn/Public/Uploads/2020-04-10/5e902b45cf368.png)

- excel 的设计：

  - 以下设计针对 excel 类型文件。

  - 标题区、说明区、头部区、页脚区四个区域的宽度按照总列数计算，最大值 = 20（即下面说的“总列数”不能超过这个值）

  - 标题区：总列数合并成一列，加粗加大显示

  - 摘要区：总列数合并成一列，正常字体，支持 html。设置最大高度

  - 头部区：根据摘要数目以及总列数计算几列合并成一列。

    - 如果数据格式是二维数组，如 `[["油站"=>"钓鱼岛", "日期"=>"4月3日"], ["操作员"=>"松林"]]`，则严格按照该行列分布（每行会尽可能地平均分布）；
    - 如果提供的是一维数组，则程序自动计算：
      - 每行不超过 4 个摘要；
      - 摘要数 * 2 <= 总列数；
      - 摘要数是奇数的话，最后一行少；
    - 以数组的 key 作为标题，value 作为值；
    - 字号：正常字号；

  - 页脚区：同摘要区；

  - 数据区：

    - 数据：严格结构的二维/三维数组：

      - 如果只有列标题，则数据是二维数组，其中第一维对应行数，第二维对应列数
      - 如果同时有列标题和行标题，则数据是三维数组，第一维对应行标题数目（大行数），第二维对应真正的行数（小行数），第三维对应列数
      - 暂不支持 excel 公式，需要数据源算好

    - 列标题（ceil-header）：

      - 加粗；

      - 默认情况下，数组的 key 作为列名；

      - 以树形结构定义列的组合方式，如：

        

        ```
        {  {      "name":"source",      "title":"来源方式"  },  {      "name":"recharge",      "title":"充值",      "children" => [          {              "name":"recharge_num",              "title":"充值笔数"          },          {              "name":"pay_money",              "title":"付款金额"          },          {              "name":"_",              "title":"其中",              "children": [                  {                      "name":"wechat",                      "title":"微信支付"                  },                  {                      "name":"alipay",                      "title":"支付宝"                  }              ]          },          {              "name":"recharge_money",              "title":"充值金额"          },          {              "name":"reduction",              "title":"优惠汇总"          }      ]  },  {      "name":"refund",      "title":"退款",      "children":[          {              "name":"refund_num",              "title":"退款笔数"          },          {              "name":"refund_money",              "title":"退款金额"          },          {              "name":"real_refund_money",              "title":"实退金额"          }      ]  }}
        ```

        对应的数组格式（PHP）：

        ```
        $a = [  [      'wx_micropay' => 130,      'wx_pay' => 150,      'ali_micropay' => 100,      'ali_pay' => 200,  ],  [      'wx_micropay' => 30,      'wx_pay' => 23,      'ali_micropay' => 111,      'ali_pay' => 56,  ],];
        ```

    - 列标题数据结构说明：

      - 由树形节点（Node）构成；

      - 每个节点的格式：

        ```
        {  "name":"对应源二维数组中第二维的 key，如果没有映射到或者填_或者不提供都会被忽略。如果设置成`__row__`且有行标题，则表示该列是行标题的列标题",  "title":"excel 中列名称，如果不提供，则取 name 作为 title。name 和 title 至少需要提供一个",  "type": "数据类型",  "format":"格式化",  "width":"列宽。默认自适应",  "height":"数据行高度。默认自适应",  "align":"水平对齐方式：center|left|right，默认 center",  "v-align"垂直对齐方式：top|middle|bottom，默认 middle",  "color": "FFFEFE",// 颜色也可以用命名颜色：black,white,red,green,blue,yellow,cyan  "bold":true,// 加粗  "bg_color":true,// 背景色  // condition_style 里面可以放 color、bold，用来设置条件样式，这里的样式优先级高于其他的  "condition_style": [      {          "color":"red",          "bold":true,          "bg_color":true,// 背景色          "condition":">=0 or <=-10",// 条件语句，类似 SQL。支持的运算符：>、>=、<、<=、!=、=、in、like、or、and、not、()      }  ],  "children":[...] // children 里面放的是 Node}
        ```

      - 列标题的叶子节点对应到数据源数组最后一维的字段

    - 行标题：

    - 在有行标题的情况下，数据源是三维数组。

      行标题格式和列标题相同，也是树形结构，不过少了一些样式设置。每个行标题单元结构：

      ```
        {          "name":"对应源数组中第一维的 key，如果没有映射到或者填_或者不提供都会被忽略。",          "title":"行标题名称，如果不提供，则取 name 作为 title。name 和 title 至少需要提供一个",          "bg_color":true,// 背景色          "children":[...] // children 里面放的是 Node  }
      ```

      如果有行标题，需要保证其定义的行能够囊括所有的数据行，否则没有被囊括的数据无法正常显示。

      

    - 列标题可以如下设置一列来对应行标题：

      ```
        {    {        "name":"_row_header",        "title":""    },    ... }
      ```

- 模板定义：

  - 如果表头格式是固定的（静态），可以提前知道的，则建议在提交下载申请时通过 template 参数指定；

  - 如果数据列是不确定的，只有在实际下载数据时才能确定（动态），需要动态规划表头格式，则可以在申请下载时不提供 template 参数，而在 source_url 的返回值里面通过 template 参数动态指定；

  - source_url 返回的 template 优先于下载申请时提供的 template；

  - 对 source_url 的循环调用，返回的 template 应该相同。下载中心只会取第一次调用时获取到的 template；

  - template 格式：

    ```
      {"row":{...},"ceil":{...}} // 同时有行标题和列标题
    ```

    或者：

    ```
      {...} // 只有列标题
    ```

- source_url 格式：

  - 业务系统提交下载申请时，需指定 source_url 作为数据源获取 url。url 格式：

    ```
    METHOD: GETurl: https://example.com/a/b/c?...
    ```

  - 下载中心会循环调用此接口拉取源数据。请将相关数据过滤条件作为 url 参数附上，下载中心调用的时候会原样请求，另加上 page = 0,page_size = 500 来分页（page 从 0 开始）

  - 该接口返回的数据格式（json）：

    ```
      {      "template": {...}, // 设置表头格式，可选      "total": 10000, // 一共有多少数据，必需      "data":[{...},{...}] // 二维数据列表，必需      "header":{"油站":"钓鱼岛","姓名":"张三"}, // 头部区，一维或二维数组。可选      "footer":{"签名":"","日期":""}, // 页脚区，一维或二维数组。可选  }
    ```

- 拉取数据步骤：

  1. 每个任务建立单独的文件夹；
  2. 下载中心第一次调用 source_url 时只下载一条数据（page_size=1），目的是获取相关非数据信息：template、total、header、footer（注意这些数据只以第一次获取的为准）。
  3. 如果返回数据有 template，则以此 template 作为表头模板；
  4. 根据 total 大小判断是线性拉取还是开启多个协程并行拉取（total / page_size <= 400 则线性拉取，否则并行拉取，并发数为 total / (page_size*100)）且不超过 5 个协程；
  5. 并行拉取的情况下每个协程会生成独立的源文件，生成目标文件的时候需要取这些文件里面的所有数据（主协程会保证各协程之间数据的顺序性，子协程内部会保证自己生成的数据的顺序性，因而合并后数据顺序不变）；
  6. 数据获取完成，生成目标文件；
  7. 通知对端获取数据；
  8. 如果拉取失败，会重试，最多重试 5 次，时间间隔依次拉长；
  9. 最终如果获取数据失败，则通知下载失败，记录状态，并清理数据；
  10. 考虑服务崩溃（或人为杀死）的情况：
  11. 服务崩溃重启后，需能够继续前面的工作进行：
  12. 如果在 5 分钟之内重启，且数据总数和上次相同，则尽可能接着前面的工作进行，否则需清理临时数据，从头开始；
  13. 为了能够在崩溃重启后接着前面的工作，拉取过程中会记录一些信息到相关文件中，崩溃重启后读取文件中信息来继续任务；
  14. 文件：

  - 源文件拉取后以 csv 格式保存；
  - 正在获取数据的临时文件：.tmp.csv；
  - 拉取完成的源文件：.source.csv;
  - 元数据文件：.meta

- 生成目标文件：

- 如果是生成 csv，则直接合并源文件成一个文件；

- 如果是生成 excel，则按照格式生成；

- 每个 excel 文件大小不超过 10M，不超过 80W 行（这些数据需要实际调试）；

- 通知：

  - 生成目标文件后，通知对端：
    - web socket 通知（如果对方建立了连接的话）；
    - 回调 url 通知（如果对方提供了的话）；
    - 对方被动拉取；

- 客户端获取数据的方式—浏览器版：
  ![img](http://showdoc.wcc.cn/Public/Uploads/2020-04-15/5e96dd6b480b1.png)

- 客户端获取数据的方式—服务器版：
  ![img](http://showdoc.wcc.cn/Public/Uploads/2020-04-15/5e96deaeed882.png)

- 数据下载：
  目标文件是生成在一台服务器上，需要用户到这台来下载。
  **方案：**使用 CDN。

- 系统设计：
  ![img](http://showdoc.wcc.cn/Public/Uploads/2020-04-24/5ea2673a568ba.png)
  **说明：**

1. 每个 worker 进程只有一个 job 队列消费者从队列中取任务；
2. worker 进程中 channel 的作用：一方面让队列消费者和 job 调度器解耦；另一方面用来限制每个进程同时处理的最大任务数；

- 任务状态：
  ![img](http://showdoc.wcc.cn/Public/Uploads/2020-04-24/5ea26a3bd4fb9.png)
  **说明：**

1. 第 1 步将任务插入到数据库中，此时数据库中该任务状态是：**待处理**，然后将任务加入到待处理队列中；
2. worker 进程中的队列消费者从队列中取出任务，投递到 channel 中；
3. JobSchedular 从 channel 中取数据，拆分数据并分配协程处理，然后将数据库状态改成**处理中**，并记录下开始处理的时间；
4. 协程取源数据完成，告知 JobSchedular；
5. JobSchedular 投递异步 task 生成目标文件；
6. task 处理完成，返回告知 JobSchedular 处理完成；
7. JobSchedular 将任务状态改成**处理成功**；
8. 取数据的协程或者 task 任务如果告知处理失败，则 JobSchedular 会将任务状态改成**处理失败**；
9. 异常检测程序检测到 task 处理时间过久的话，则将任务改成**处理失败**；

- 异常：

  - 第 1 步将任务插入到数据库中，此时数据库中该任务状态是：**待处理**，然后将任务加入到待处理队列中。

  - 如果任务长时间处于**待处理**状态（如插入队列失败、队列崩溃了、处理进程崩溃了），则健康监测进程会将其重新加入到队列中；

  - 由于上面的步骤，理论上有可能一个任务会被多个进程重复执行（重复入列），我们通过以下手段保证任务只被一个进程处理：

    - 调度器接收到任务后先去检查任务状态，只有处于**待处理**状态的任务才会被调度器处理，此时调度器将该任务状态更新成**处理中**，并拆分任务、投递给工作协程；

  - 调度器收到任务投递给协程执行，并将任务状态改成

    执行中

    。此时如果协程获取数据失败，或者 task 进程生成目标文件失败，那么该任务会一直处于

    执行中

    状态。我们通过以下手段保证执行的正确性：

    - 我们从所有运行中的服务器选择一台作为主服务器，主服务器上运行一个定时任务执行健康检查。所有的从服务器和主服务器建立一个长连接，实时将当前服务正在处理的任务列表上报给主服务器。主服务器根据这些信息来判断一个**处理中**的任务到底是正在执行还是中途失败需要重新执行。

- 工作流节点（状态/动作）：

  - 新任务（来自 http 请求） / 存到数据库，入列
  - 待处理（队列消费者从队列取出） / 获取源数据
  - 源数据就绪（源数据已经全部拉到本地形成临时文件。注意：对方接口返回空数据也认为是就绪）/ 生成目标数据
  - 源数据获取失败 （未成功获取全部源数据，可能对方接口不可用） / 更改数据库状态为处理失败并标记处理次数
  - 目标文件就绪（已生成目标文件到本地） / 上传到 CDN
  - 目标文件生成失败 / 更改数据库状态为处理失败并标记处理次数
  - 上传完成（本地目标文件已经成功上传到 CDN / 通知客户端
  - 上传失败 / 更改数据库状态为处理失败并标记处理次数
  - 重试（超时未成功或者发生可重试的失败，且未超过重试次数）/ 重新入列